<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>LaserDeMag.io.file_handler API documentation</title>
<meta name="description" content="Obsługa zapisu i odczytu danych symulacji …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>LaserDeMag.io.file_handler</code></h1>
</header>
<section id="section-intro">
<p>Obsługa zapisu i odczytu danych symulacji.</p>
<hr>
<p>Simulation data saving and loading utilities.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="LaserDeMag.io.file_handler.generate_graph"><code class="name flex">
<span>def <span class="ident">generate_graph</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_graph():
    &#34;&#34;&#34;
    Uruchamia graficzny interfejs do generowania wykresów z plików Excel.

    Funkcja otwiera okno aplikacji, w którym użytkownik może:
      - wybrać plik Excel (.xlsx, .xls),
      - wskazać arkusze do analizy,
      - wygenerować i zapisać wykresy na podstawie danych z tych arkuszy.

    Wykresy generowane są dla zdefiniowanych kolumn (np. elektronów, fononów, magnetyzacji),
    a następnie zapisywane w tym samym katalogu co wybrany plik Excel,
    z predefiniowanymi nazwami plików PNG. Każdy wykres zawiera dane z wielu arkuszy
    w formie osobnych linii z legendą.

    Obsługiwane są sytuacje wyjątkowe:
      - brak wyboru pliku lub arkusza,
      - błędy przy odczycie arkuszy,
      - błędy przy generowaniu wykresów.
    Komunikaty błędów i sukcesów wyświetlane są w oknach dialogowych.

    Args:
        Brak (funkcja nie przyjmuje parametrów, wszystkie dane wybierane są przez GUI).

    Returns:
        None

    Raises:
        Exception: Gdy wystąpi błąd przy odczytywaniu arkuszy lub generowaniu wykresów.

    ---
    Launches a graphical interface for generating plots from Excel files.

    The function opens a GUI window where the user can:
      - select an Excel file (.xlsx, .xls),
      - choose sheets to analyze,
      - generate and save plots based on the selected sheets.

    Plots are created for predefined columns (e.g., electrons, phonons, magnetization)
    and saved as PNG files in the same directory as the chosen Excel file.
    Each plot combines data from multiple sheets, displayed as separate lines with legends.

    The function handles exceptional situations:
      - no file or sheet selected,
      - errors reading sheets,
      - errors generating plots.
    All errors and success messages are shown in dialog boxes.

    Args:
        None (the function takes no parameters; all inputs are provided through the GUI).

    Returns:
        None

    Raises:
        Exception: If an error occurs while reading sheets or generating plots.
    &#34;&#34;&#34;
    def select_file():
        filepath = filedialog.askopenfilename(filetypes=[(&#34;Excel files&#34;, &#34;*.xlsx *.xls&#34;)])
        if not filepath:
            return

        try:
            excel = pd.ExcelFile(filepath)
            sheet_names = excel.sheet_names

            listbox.delete(0, tk.END)
            for name in sheet_names:
                listbox.insert(tk.END, name)

            btn_generate.config(state=&#34;normal&#34;)
            root.filepath = filepath
            root.sheet_names = sheet_names
        except Exception as e:
            messagebox.showerror(&#34;Error&#34;, f&#34;Failed to load file: {e}&#34;)

    def generate_plots():
        selected_indices = listbox.curselection()
        if not selected_indices:
            messagebox.showwarning(&#34;Warning&#34;, &#34;Please select at least one sheet.&#34;)
            return

        filepath = root.filepath
        selected_sheets = [root.sheet_names[i] for i in selected_indices]
        dataframes = {}

        try:
            for sheet in selected_sheets:
                df = pd.read_excel(filepath, sheet_name=sheet, skiprows=4)
                dataframes[sheet] = df
        except Exception as e:
            messagebox.showerror(&#34;Error&#34;, f&#34;Error while reading sheets: {e}&#34;)
            return

        try:
            colors = plt.get_cmap(&#34;tab10&#34;)

            wykresy = [
                (1, &#34;M3TM Koopmans electrons&#34;, &#34;M3TM_Koopmans_electrons.png&#34;),
                (4, &#34;M3TM Koopmans phonons&#34;, &#34;M3TM_Koopmans_phonons.png&#34;),
                (7, &#34;Magnetization&#34;, &#34;graph_magnetization.png&#34;)
            ]

            for idx, (col_idx, tytul, filename) in enumerate(wykresy):
                plt.figure(figsize=(10, 6))
                rysowano = False

                for i, (sheet, df) in enumerate(dataframes.items()):
                    if df.shape[1] &gt; col_idx:
                        x = df.iloc[:, 0]
                        y = df.iloc[:, col_idx]

                        if pd.api.types.is_numeric_dtype(y):
                            plt.plot(x, y, label=sheet, color=colors(i))
                            rysowano = True

                if rysowano:
                    plt.title(tytul)
                    plt.xlabel(&#34;czas&#34;)
                    plt.ylabel(tytul)
                    plt.legend()
                    plt.grid(True)
                    plt.tight_layout()

                    out_path = os.path.join(os.path.dirname(filepath), filename)
                    plt.savefig(out_path)
                plt.close()

            messagebox.showinfo(&#34;Success&#34;, &#34;Plots have been saved.&#34;)
        except Exception as e:
            messagebox.showerror(&#34;Error&#34;, f&#34;Could not generate plots: {e}&#34;)

    root = tk.Tk()
    root.title(&#34;Excel Plot Generator&#34;)

    btn_file = tk.Button(root, text=&#34;Select Excel file&#34;, command=select_file)
    btn_file.pack(pady=10)

    tk.Label(root, text=&#34;Select sheets:&#34;).pack()
    listbox = Listbox(root, selectmode=MULTIPLE, width=50)
    listbox.pack(pady=5)

    btn_generate = tk.Button(root, text=&#34;Generate plots&#34;, command=generate_plots, state=&#34;disabled&#34;)
    btn_generate.pack(pady=10)

    root.mainloop()</code></pre>
</details>
<div class="desc"><p>Uruchamia graficzny interfejs do generowania wykresów z plików Excel.</p>
<p>Funkcja otwiera okno aplikacji, w którym użytkownik może:
- wybrać plik Excel (.xlsx, .xls),
- wskazać arkusze do analizy,
- wygenerować i zapisać wykresy na podstawie danych z tych arkuszy.</p>
<p>Wykresy generowane są dla zdefiniowanych kolumn (np. elektronów, fononów, magnetyzacji),
a następnie zapisywane w tym samym katalogu co wybrany plik Excel,
z predefiniowanymi nazwami plików PNG. Każdy wykres zawiera dane z wielu arkuszy
w formie osobnych linii z legendą.</p>
<p>Obsługiwane są sytuacje wyjątkowe:
- brak wyboru pliku lub arkusza,
- błędy przy odczycie arkuszy,
- błędy przy generowaniu wykresów.
Komunikaty błędów i sukcesów wyświetlane są w oknach dialogowych.</p>
<h2 id="args">Args</h2>
<p>Brak (funkcja nie przyjmuje parametrów, wszystkie dane wybierane są przez GUI).</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Gdy wystąpi błąd przy odczytywaniu arkuszy lub generowaniu wykresów.</dd>
</dl>
<hr>
<p>Launches a graphical interface for generating plots from Excel files.</p>
<p>The function opens a GUI window where the user can:
- select an Excel file (.xlsx, .xls),
- choose sheets to analyze,
- generate and save plots based on the selected sheets.</p>
<p>Plots are created for predefined columns (e.g., electrons, phonons, magnetization)
and saved as PNG files in the same directory as the chosen Excel file.
Each plot combines data from multiple sheets, displayed as separate lines with legends.</p>
<p>The function handles exceptional situations:
- no file or sheet selected,
- errors reading sheets,
- errors generating plots.
All errors and success messages are shown in dialog boxes.</p>
<h2 id="args_1">Args</h2>
<p>None (the function takes no parameters; all inputs are provided through the GUI).</p>
<h2 id="returns_1">Returns</h2>
<p>None</p>
<h2 id="raises_1">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If an error occurs while reading sheets or generating plots.</dd>
</dl></div>
</dd>
<dt id="LaserDeMag.io.file_handler.load_simulation_parameters"><code class="name flex">
<span>def <span class="ident">load_simulation_parameters</span></span>(<span>file_path, parent_widget)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_simulation_parameters(file_path,parent_widget):
    &#34;&#34;&#34;
       Wczytuje dane symulacji z pliku JSON.

       Args:
           file_path (str): Ścieżka do pliku .json
           parent_widget (QWidget): Rodzic do wyświetlenia komunikatów błędów.

       Returns:
           dict: Dane do wypełnienia formularza symulacji.

       Raises:
           ValueError: Gdy format pliku lub dane są niepoprawne.

       ---
       Loads simulation parameters from a JSON file.

       Args:
           file_path (str): Path to the .json file.
           parent_widget (QWidget): Parent widget for displaying error messages.

       Returns:
           dict: Parameters for simulation form filling.

       Raises:
           ValueError: If file or data is invalid.
       &#34;&#34;&#34;
    try:
        with open(file_path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
            data = json.load(f)

        if not isinstance(data, dict):
            error_message_format = parent_widget.error_invalid_format.format(fields=&#34;, &#34;.join(REQUIRED_USER_FIELDS))
            raise ValueError(error_message_format)

        missing = REQUIRED_USER_FIELDS - data.keys()
        if missing:
            error_message = parent_widget.missing_fields_error.format(fields=&#34;, &#34;.join(missing))
            raise ValueError(error_message)

        for key in REQUIRED_USER_FIELDS:
            if key == &#34;material&#34;:
                continue
            value = data[key]
            if not isinstance(value, (int, float)):
                raise ValueError(parent_widget.error_invalid_type.format(field=key))

        material = data.get(&#34;material&#34;)
        if material not in ALLOWED_MATERIALS:
            raise ValueError(parent_widget.error_invalid_material.format(
                material=material,
                allowed=&#34;, &#34;.join(ALLOWED_MATERIALS)
            ))

        return {key: data[key] for key in REQUIRED_USER_FIELDS}

    except json.JSONDecodeError:
        raise ValueError(parent_widget.error_json_decode)

    except FileNotFoundError:
        raise ValueError(parent_widget.error_file_not_found.format(path=file_path))</code></pre>
</details>
<div class="desc"><p>Wczytuje dane symulacji z pliku JSON.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Ścieżka do pliku .json</dd>
<dt><strong><code>parent_widget</code></strong> :&ensp;<code>QWidget</code></dt>
<dd>Rodzic do wyświetlenia komunikatów błędów.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dane do wypełnienia formularza symulacji.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Gdy format pliku lub dane są niepoprawne.</dd>
</dl>
<hr>
<p>Loads simulation parameters from a JSON file.</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the .json file.</dd>
<dt><strong><code>parent_widget</code></strong> :&ensp;<code>QWidget</code></dt>
<dd>Parent widget for displaying error messages.</dd>
</dl>
<h2 id="returns_1">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Parameters for simulation form filling.</dd>
</dl>
<h2 id="raises_1">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If file or data is invalid.</dd>
</dl></div>
</dd>
<dt id="LaserDeMag.io.file_handler.save_simulation_parameters"><code class="name flex">
<span>def <span class="ident">save_simulation_parameters</span></span>(<span>params, file_path, file_format, parameter_encoder, quantity_to_plain_func)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_simulation_parameters(params, file_path, file_format, parameter_encoder, quantity_to_plain_func):
    &#34;&#34;&#34;
    Zapisuje dane symulacji w formacie JSON lub XML.

    Args:
        params (dict): Parametry symulacji do zapisania.
        file_path (str): Ścieżka pliku docelowego (bez rozszerzenia).
        file_format (str): Format zapisu (&#34;json&#34; lub &#34;xml&#34;).
        parameter_encoder (type): Niestandardowy encoder JSON.
        quantity_to_plain_func (callable): Funkcja konwertująca jednostki na wartości tekstowe.

    Returns:
        str: Pełna ścieżka zapisanego pliku.

    Raises:
        Exception: Gdy zapis się nie powiedzie.

    ---
    Saves simulation parameters to JSON or XML format.

    Args:
        params (dict): Parameters to be saved.
        file_path (str): Output file path (without extension).
        file_format (str): File format (&#34;json&#34; or &#34;xml&#34;).
        parameter_encoder (type): Custom JSON encoder class.
        quantity_to_plain_func (callable): Function to convert quantities to plain values.

    Returns:
        str: Full path to the saved file.

    Raises:
        Exception: If saving fails.
    &#34;&#34;&#34;
    if file_format == &#34;json&#34;:
        if not file_path.lower().endswith(&#34;.json&#34;):
            file_path += &#34;.json&#34;
        with open(file_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
            json.dump(params, f, indent=2, ensure_ascii=False, cls=parameter_encoder)
        return file_path

    elif file_format == &#34;xml&#34;:
        if not file_path.lower().endswith(&#34;.xml&#34;):
            file_path += &#34;.xml&#34;

        plain_params = quantity_to_plain_func(params)
        root = ET.Element(&#34;simulation_parameters&#34;)

        def add_dict_to_xml(parent, data):
            if isinstance(data, dict):
                for key, value in data.items():
                    child = ET.SubElement(parent, str(key))
                    add_dict_to_xml(child, value)
            elif isinstance(data, list):
                for item in data:
                    item_elem = ET.SubElement(parent, &#34;item&#34;)
                    add_dict_to_xml(item_elem, item)
            else:
                parent.text = str(data)

        add_dict_to_xml(root, plain_params)

        rough_string = ET.tostring(root, &#39;utf-8&#39;)
        reparsed = xml.dom.minidom.parseString(rough_string)
        with open(file_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
            f.write(reparsed.toprettyxml(indent=&#34;  &#34;))

        return file_path

    else:
        raise ValueError(&#34;Unsupported file format: &#34; + file_format)</code></pre>
</details>
<div class="desc"><p>Zapisuje dane symulacji w formacie JSON lub XML.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Parametry symulacji do zapisania.</dd>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Ścieżka pliku docelowego (bez rozszerzenia).</dd>
<dt><strong><code>file_format</code></strong> :&ensp;<code>str</code></dt>
<dd>Format zapisu ("json" lub "xml").</dd>
<dt><strong><code>parameter_encoder</code></strong> :&ensp;<code>type</code></dt>
<dd>Niestandardowy encoder JSON.</dd>
<dt><strong><code>quantity_to_plain_func</code></strong> :&ensp;<code>callable</code></dt>
<dd>Funkcja konwertująca jednostki na wartości tekstowe.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Pełna ścieżka zapisanego pliku.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Gdy zapis się nie powiedzie.</dd>
</dl>
<hr>
<p>Saves simulation parameters to JSON or XML format.</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Parameters to be saved.</dd>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Output file path (without extension).</dd>
<dt><strong><code>file_format</code></strong> :&ensp;<code>str</code></dt>
<dd>File format ("json" or "xml").</dd>
<dt><strong><code>parameter_encoder</code></strong> :&ensp;<code>type</code></dt>
<dd>Custom JSON encoder class.</dd>
<dt><strong><code>quantity_to_plain_func</code></strong> :&ensp;<code>callable</code></dt>
<dd>Function to convert quantities to plain values.</dd>
</dl>
<h2 id="returns_1">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Full path to the saved file.</dd>
</dl>
<h2 id="raises_1">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If saving fails.</dd>
</dl></div>
</dd>
<dt id="LaserDeMag.io.file_handler.save_simulation_report"><code class="name flex">
<span>def <span class="ident">save_simulation_report</span></span>(<span>params,<br>material_name,<br>material_props,<br>plot_data,<br>parent=None,<br>simulation_duration=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_simulation_report(params, material_name, material_props, plot_data, parent=None, simulation_duration=None):
    &#34;&#34;&#34;
    Tworzy i zapisuje raport z przebiegu symulacji do pliku tekstowego.

    Args:
        params (dict): Parametry wejściowe symulacji.
        material_name (str): Nazwa materiału.
        material_props (dict): Właściwości materiału.
        plot_data (dict): Dane do wykresów (linie, mapy).
        parent (QWidget, optional): Rodzic do komunikatów GUI.
        simulation_duration (float, optional): Czas trwania symulacji w sekundach.

    Returns:
        None

    ---
    Generates and saves a simulation report to a text file.

    Args:
        params (dict): Input parameters of the simulation.
        material_name (str): Name of the material.
        material_props (dict): Material properties.
        plot_data (dict): Plot data (lines and maps).
        parent (QWidget, optional): Parent widget for error messages.
        simulation_duration (float, optional): Simulation duration in seconds.

    Returns:
        None
    &#34;&#34;&#34;
    file_path, selected_filter = QFileDialog.getSaveFileName(
        parent,
        &#34;Save simulation report&#34;,
        &#34;&#34;,
        &#34;Text files (*.txt);;All files (*)&#34;,
        options=QFileDialog.Option.DontUseNativeDialog
    )

    if not file_path:
        return

    if not os.path.splitext(file_path)[1]:
        file_path += &#34;.txt&#34;

    try:
        with open(file_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
            f.write(&#34;LaserDeMag simulation report\n&#34;)
            f.write(f&#34;Simulation date: {datetime.datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)}\n&#34;)
            if simulation_duration is not None:
                f.write(f&#34;Simulation duration: {simulation_duration:.2f} seconds\n&#34;)
            f.write(&#34;\n--- Simulation parameters ---\n&#34;)
            for key, val in params.items():
                f.write(f&#34;{key}: {val}\n&#34;)

            f.write(f&#34;\n--- Material ---\n&#34;)
            f.write(f&#34;Name: {material_name}\n&#34;)
            for prop_key, prop_val in material_props.items():
                f.write(f&#34;{prop_key}: {prop_val}\n&#34;)

            f.write(&#34;\n--- Simulation results (selected data) ---\n&#34;)
            if &#39;maps&#39; in plot_data:
                f.write(&#34;Data maps:\n&#34;)

                maps = plot_data[&#39;maps&#39;]
                delays = maps.get(&#34;delays&#34;, [])
                distances = maps.get(&#34;distances&#34;, [])
                temp_map = maps.get(&#34;temp_map&#34;, None)

                f.write(f&#34;  delays: {delays[:5]}... (total {len(delays)})\n&#34;)
                f.write(f&#34;  distances: {distances[:5]}... (total {len(distances)})\n&#34;)

                if isinstance(temp_map, (list, np.ndarray)):
                    arr = np.array(temp_map)
                    f.write(f&#34;  temp_map shape: {arr.shape} (time, space, component)\n&#34;)

                    if arr.ndim == 3 and arr.shape[2] &gt; 2:
                        f.write(&#34;  Sample values (T_spin):\n&#34;)
                        for t in range(min(2, arr.shape[0])):
                            f.write(f&#34;    {arr[t, :5, 2]}...\n&#34;)
                else:
                    f.write(&#34;  temp_map: missing or invalid format\n&#34;)

            if &#39;lines&#39; in plot_data:
                f.write(&#34;Line plots:\n&#34;)
                for i, d in enumerate(plot_data[&#39;lines&#39;]):
                    f.write(f&#34;  Line {i + 1} - {d.get(&#39;title&#39;, &#39;&#39;)}:\n&#34;)
                    f.write(f&#34;    x: {d.get(&#39;x&#39;, [])[:5]}... (total {len(d.get(&#39;x&#39;, []))})\n&#34;)
                    f.write(f&#34;    y: {d.get(&#39;y&#39;, [])[:5]}... (total {len(d.get(&#39;y&#39;, []))})\n&#34;)

            f.write(&#34;\n--- End of report ---\n&#34;)

        QMessageBox.information(
            parent,
            &#34;Save successful&#34;,
            f&#34;The report was successfully saved to:\n{file_path}&#34;
        )

    except Exception as e:
        QMessageBox.critical(
            parent,
            &#34;Save error&#34;,
            f&#34;An error occurred while saving the report:\n{str(e)}&#34;
        )</code></pre>
</details>
<div class="desc"><p>Tworzy i zapisuje raport z przebiegu symulacji do pliku tekstowego.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Parametry wejściowe symulacji.</dd>
<dt><strong><code>material_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Nazwa materiału.</dd>
<dt><strong><code>material_props</code></strong> :&ensp;<code>dict</code></dt>
<dd>Właściwości materiału.</dd>
<dt><strong><code>plot_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dane do wykresów (linie, mapy).</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>QWidget</code>, optional</dt>
<dd>Rodzic do komunikatów GUI.</dd>
<dt><strong><code>simulation_duration</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Czas trwania symulacji w sekundach.</dd>
</dl>
<h2 id="returns">Returns</h2>
<h2 id="none">None</h2>
<p>Generates and saves a simulation report to a text file.</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Input parameters of the simulation.</dd>
<dt><strong><code>material_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the material.</dd>
<dt><strong><code>material_props</code></strong> :&ensp;<code>dict</code></dt>
<dd>Material properties.</dd>
<dt><strong><code>plot_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Plot data (lines and maps).</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>QWidget</code>, optional</dt>
<dd>Parent widget for error messages.</dd>
<dt><strong><code>simulation_duration</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Simulation duration in seconds.</dd>
</dl>
<h2 id="returns_1">Returns</h2>
<p>None</p></div>
</dd>
<dt id="LaserDeMag.io.file_handler.save_simulation_to_excel"><code class="name flex">
<span>def <span class="ident">save_simulation_to_excel</span></span>(<span>params, plot_data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_simulation_to_excel(params, plot_data):
    &#34;&#34;&#34;
       Zapisuje dane symulacji do pliku Excel (XLSX) w katalogu uruchomienia aplikacji.

       Funkcja tworzy (jeśli nie istnieje) lub otwiera plik o nazwie &#39;Simulations.xlsx&#39; w folderze,
       w którym uruchamiana jest aplikacja. Dla każdej symulacji tworzony jest nowy arkusz,
       którego nazwa zawiera liczbę warstw i moc lasera, np.: &#39;N=4, Fluence=2.5&#39;.

       Jeśli arkusz o danej nazwie już istnieje, funkcja doda numer sufiksu (np. _1, _2 itd.),
       aby uniknąć nadpisywania danych.

       Parametry wejściowe zapisywane są w pierwszych dwóch wierszach arkusza,
       a dane z wykresów liniowych w układzie poziomym (każdy wykres w dwóch kolumnach: x i y),
       z jedną pustą kolumną odstępu między kolejnymi wykresami.

       Args:
           params (dict): Parametry symulacji do zapisania. Muszą zawierać co najmniej:
                          - &#34;liczba_warstw&#34; (int)
                          - &#34;moc_lasera&#34; (float lub str)
           plot_data (dict): Dane wykresów w formacie {&#34;lines&#34;: [{&#34;title&#34;: ..., &#34;x&#34;: [...], &#34;y&#34;: [...]}]}.

       Returns:
           None

       Raises:
           Exception: Gdy zapis do pliku się nie powiedzie.

       ---
       Saves simulation data to an Excel (XLSX) file in the application&#39;s execution directory.

       The function creates (if missing) or opens &#39;Simulations.xlsx&#39; and adds a new sheet for each simulation.
       The sheet name is based on the number of layers and laser fluence, e.g., &#39;N=4, Fluence=2.5&#39;.

       If a sheet with that name already exists, the function adds a numeric suffix to avoid overwriting.

       The function writes input parameters in the first two rows,
       and line chart data in a horizontal layout (each chart gets two columns: x and y),
       with one empty column of spacing between charts.

       Args:
           params (dict): Simulation parameters to save. Must include at least:
                          - &#34;liczba_warstw&#34; (int)
                          - &#34;moc_lasera&#34; (float or str)
           plot_data (dict): Plot data in the format {&#34;lines&#34;: [{&#34;title&#34;: ..., &#34;x&#34;: [...], &#34;y&#34;: [...]}]}.

       Returns:
           None

       Raises:
           Exception: If saving the file fails.
       &#34;&#34;&#34;
    current_dir = Path.cwd()
    filename = current_dir / &#34;Simulations.xlsx&#34;

    num_layers = params.get(&#34;N&#34;, &#34;unknown&#34;)
    fluence = params.get(&#34;fluence&#34;, &#34;unknown&#34;)
    sheet_name = f&#34;N={num_layers}, Fluence={fluence}&#34;

    if filename.exists():
        wb = load_workbook(filename)
    else:
        wb = Workbook()
        default_sheet = wb.active
        wb.remove(default_sheet)

    original_name = sheet_name
    counter = 1
    while sheet_name in wb.sheetnames:
        sheet_name = f&#34;{original_name}_{counter}&#34;
        counter += 1

    ws = wb.create_sheet(title=sheet_name)

    parameter_keys = list(params.keys())
    ws.append(parameter_keys)
    parameter_values = [params[key] for key in parameter_keys]
    ws.append(parameter_values)
    ws.append([])

    if &#39;lines&#39; in plot_data:
        max_len = 0
        for line in plot_data[&#39;lines&#39;]:
            max_len = max(max_len, len(line.get(&#39;x&#39;, [])))

        col = 1
        for i, line in enumerate(plot_data[&#39;lines&#39;]):
            x_vals = line.get(&#39;x&#39;, [])
            y_vals = line.get(&#39;y&#39;, [])
            title = line.get(&#39;title&#39;, f&#34;Line {i + 1}&#34;)

            ws.cell(row=4, column=col, value=f&#34;{title} - x&#34;)
            ws.cell(row=4, column=col + 1, value=f&#34;{title} - y&#34;)

            for row_i in range(max_len):
                x = x_vals[row_i] if row_i &lt; len(x_vals) else None
                y = y_vals[row_i] if row_i &lt; len(y_vals) else None
                ws.cell(row=5 + row_i, column=col, value=x)
                ws.cell(row=5 + row_i, column=col + 1, value=y)

            col += 3

    wb.save(filename)
    print(f&#34;File saved to: {filename}, sheet: {sheet_name}&#34;)</code></pre>
</details>
<div class="desc"><p>Zapisuje dane symulacji do pliku Excel (XLSX) w katalogu uruchomienia aplikacji.</p>
<p>Funkcja tworzy (jeśli nie istnieje) lub otwiera plik o nazwie 'Simulations.xlsx' w folderze,
w którym uruchamiana jest aplikacja. Dla każdej symulacji tworzony jest nowy arkusz,
którego nazwa zawiera liczbę warstw i moc lasera, np.: 'N=4, Fluence=2.5'.</p>
<p>Jeśli arkusz o danej nazwie już istnieje, funkcja doda numer sufiksu (np. _1, _2 itd.),
aby uniknąć nadpisywania danych.</p>
<p>Parametry wejściowe zapisywane są w pierwszych dwóch wierszach arkusza,
a dane z wykresów liniowych w układzie poziomym (każdy wykres w dwóch kolumnach: x i y),
z jedną pustą kolumną odstępu między kolejnymi wykresami.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Parametry symulacji do zapisania. Muszą zawierać co najmniej:
- "liczba_warstw" (int)
- "moc_lasera" (float lub str)</dd>
<dt><strong><code>plot_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dane wykresów w formacie {"lines": [{"title": &hellip;, "x": [&hellip;], "y": [&hellip;]}]}.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Gdy zapis do pliku się nie powiedzie.</dd>
</dl>
<hr>
<p>Saves simulation data to an Excel (XLSX) file in the application's execution directory.</p>
<p>The function creates (if missing) or opens 'Simulations.xlsx' and adds a new sheet for each simulation.
The sheet name is based on the number of layers and laser fluence, e.g., 'N=4, Fluence=2.5'.</p>
<p>If a sheet with that name already exists, the function adds a numeric suffix to avoid overwriting.</p>
<p>The function writes input parameters in the first two rows,
and line chart data in a horizontal layout (each chart gets two columns: x and y),
with one empty column of spacing between charts.</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Simulation parameters to save. Must include at least:
- "liczba_warstw" (int)
- "moc_lasera" (float or str)</dd>
<dt><strong><code>plot_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Plot data in the format {"lines": [{"title": &hellip;, "x": [&hellip;], "y": [&hellip;]}]}.</dd>
</dl>
<h2 id="returns_1">Returns</h2>
<p>None</p>
<h2 id="raises_1">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If saving the file fails.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="LaserDeMag.io" href="index.html">LaserDeMag.io</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="LaserDeMag.io.file_handler.generate_graph" href="#LaserDeMag.io.file_handler.generate_graph">generate_graph</a></code></li>
<li><code><a title="LaserDeMag.io.file_handler.load_simulation_parameters" href="#LaserDeMag.io.file_handler.load_simulation_parameters">load_simulation_parameters</a></code></li>
<li><code><a title="LaserDeMag.io.file_handler.save_simulation_parameters" href="#LaserDeMag.io.file_handler.save_simulation_parameters">save_simulation_parameters</a></code></li>
<li><code><a title="LaserDeMag.io.file_handler.save_simulation_report" href="#LaserDeMag.io.file_handler.save_simulation_report">save_simulation_report</a></code></li>
<li><code><a title="LaserDeMag.io.file_handler.save_simulation_to_excel" href="#LaserDeMag.io.file_handler.save_simulation_to_excel">save_simulation_to_excel</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
